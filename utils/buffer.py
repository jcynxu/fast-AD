"""
ReplayBuffer: FIFO 队列实现，用于存储合成数据
对应论文 3.5 节的 "Dynamic Buffer Mechanism"
"""

from collections import deque
import random
import torch


class ReplayBuffer:
    """
    Dynamic Buffer Mechanism (论文 3.5 节)
    
    FIFO (First-In-First-Out) 策略的缓冲区，用于存储合成数据。
    确保 Student 总是学习最新生成的、质量更高的数据。
    
    策略：
    - Push: 每个合成周期，将 Fast-AD 生成的修正图像 x_syn 推入缓冲区
    - Pop: 如果 |B| 超过最大容量，最旧的图像会被自动丢弃（deque maxlen）
    """
    def __init__(self, max_size: int = 4096):
        """
        Args:
            max_size: 缓冲区最大容量 |B|
        """
        # 使用 deque 的 maxlen 参数自动实现 FIFO
        # 当超过 max_size 时，最旧的元素会被自动丢弃
        self.buffer = deque(maxlen=max_size)
        self.max_size = max_size
    
    def push(self, images: torch.Tensor, targets: torch.Tensor):
        """
        将生成的图像和标签推入缓冲区 (Push 操作)
        
        论文描述：In each synthesis cycle, a batch of rectified images x_syn 
        generated by Fast-AD (via Eq. 7) is pushed into B.
        
        Args:
            images: [B, C, H, W] 图像张量 (合成的修正图像 x_syn)
            targets: [B] 标签张量
        """
        # 将每个样本单独存储，以便后续随机采样
        for i in range(images.size(0)):
            self.buffer.append((images[i].cpu().clone(), targets[i].cpu().clone()))
    
    def sample(self, batch_size: int) -> tuple:
        """
        从缓冲区随机采样一批数据 (用于 Student Update)
        
        论文描述：In the distillation phase, we sample a batch of synthetic images x ~ B
        
        Args:
            batch_size: 采样批次大小
            
        Returns:
            images: [B, C, H, W] 图像张量
            targets: [B] 标签张量
        """
        if len(self.buffer) == 0:
            raise ValueError("Buffer is empty, cannot sample")
        
        # 随机采样，确保 Student 学习多样化的合成数据
        batch = random.sample(self.buffer, min(len(self.buffer), batch_size))
        images = torch.stack([b[0] for b in batch])
        targets = torch.stack([b[1] for b in batch])
        return images, targets
    
    def __len__(self):
        """返回缓冲区当前大小"""
        return len(self.buffer)
    
    def is_full(self) -> bool:
        """检查缓冲区是否已满"""
        return len(self.buffer) >= self.max_size
    
    def clear(self):
        """清空缓冲区"""
        self.buffer.clear()

